{% extends "layout.html" %}

{% block title %}
  {% if category %}{{ category | capitalize }}{% else %}Главная страница{% endif %} - {{ config.company_short_name }}
{% endblock %}

{% block head %}
{{ super() }}
<style>
  /* Стили для контейнера ленты */
  .feed-container {
    display: grid;
    /* Ключевое CSS-правило для адаптивной сетки.
      Браузер сам создаст столько колонок, сколько поместится.
      - minmax(280px, 1fr): Каждая колонка будет минимум 280px
        и максимум 1fr (равномерно займет оставшееся место).
      - Это автоматически реализует ваше "от 1 до 4 тизеров".
    */
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 20px; /* Отступ между тизерами */
    padding: 20px;
    max-width: 1600px;
    margin: 0 auto;
  }

  /* Стили для самого виджета-тизера */
  .teaser-widget {
    border: 1px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    background: #fff;
    transition: transform 0.2s ease-in-out;
  }
  .teaser-widget:hover {
    transform: translateY(-5px);
  }

  .teaser-widget a {
    text-decoration: none;
    color: inherit;
    display: block;
  }

  .teaser-image {
    width: 100%;
    height: 180px;
    object-fit: cover; /* Масштабирует изображение, сохраняя пропорции */
    background-color: #eee; /* Фон для случая, если картинка не загрузится */
  }

  .teaser-content {
    padding: 15px;
  }

  .teaser-title {
    font-size: 1.1rem;
    font-weight: bold;
    color: #333;
    margin: 0 0 10px 0;
    /* Ограничиваем заголовок 2 строками */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .teaser-text {
    font-size: 0.9rem;
    color: #666;
    /* Ограничиваем текст 3 строками */
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* Индикатор загрузки */
  #loading-spinner {
    display: none; /* По умолчанию скрыт */
    width: 50px;
    height: 50px;
    border: 5px solid #f3f3f3;
    border-top: 5px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 30px auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

</style>
{% endblock %}

{% block content %}
<main>
  {% if category %}
    <h1 style="text-align: center; padding-top: 20px;">Категория: {{ category }}</h1>
  {% else %}
    <h1 style="text-align: center; padding-top: 20px;">Главная страница</h1>
  {% endif %}

  <!-- Это контейнер, куда JS будет добавлять тизеры -->
  <div id="teaser-feed" class="feed-container">
    <!-- Тизеры будут вставлены сюда -->
  </div>

  <!-- Индикатор загрузки, который появляется при подгрузке -->
  <div id="loading-spinner"></div>
</main>
{% endblock %}

{% block scripts %}
{{ super() }}
<!--
  jQuery (jquery-3.7.1.min.js) уже загружен из layout.html
  благодаря вызову {{ super() }} выше.
  Удаляем дублирующую загрузку отсюда.
-->

<script>
  $(document).ready(function() {

    // --- Глобальные переменные ---
    let currentLine = 0; // Текущая "линия" виджетов (для пагинации)
    let isLoading = false; // Флаг, чтобы не отправлять >1 запроса одновременно
    let columns = 0; // Текущее кол-во колонок в сетке

    // Получаем код категории из шаблона Jinja2
    // `tojson` безопасно обработает `None` или строку
    const CATEGORY_CODE = {{ category | default(none) | tojson }};

    // --- Утилиты ---

    /**
     * Функция "Debounce" (устранение дребезга).
     * Гарантирует, что функция-обработчик (напр. handleResize)
     * вызовется только один раз за N миллисекунд,
     * а не 100 раз в секунду при изменении размера.
     */
    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // --- Основная логика ---

    /**
     * Определяет текущее количество колонок в CSS Grid.
     * @returns {number} - Количество колонок.
     */
    function getGridColumns() {
      const feedElement = document.getElementById('teaser-feed');
      if (!feedElement) {
          console.error("Critical error: #teaser-feed not found!");
          return 0;
      }
      const style = window.getComputedStyle(feedElement);
      // 'grid-template-columns' вернет что-то вроде "298px 298px 298px"
      // Мы просто считаем количество блоков, разделенных пробелом.
      const columnString = style.getPropertyValue('grid-template-columns');
      return columnString.split(' ').length;
    }

    /**
     * Проверяет, изменилось ли количество колонок, и обновляет
     * глобальную переменную.
     * @returns {boolean} - true, если layout изменился.
     */
    function checkLayoutChange() {
      const newColumns = getGridColumns();
      if (newColumns > 0 && newColumns !== columns) {
        console.log(`Layout changed: ${columns} -> ${newColumns} columns`);
        columns = newColumns;
        return true;
      }
      return false;
    }

    /**
     * Запрашивает и рендерит тизеры для N "линий",
     * начиная с `startLine`.
     * @param {number} linesToFetch - Количество линий для загрузки (напр., 2).
     * @param {number} startLine - Номер линии, с которой начать.
     */
    function fetchTeasers(linesToFetch, startLine) {
      if (isLoading) {
          console.log("Request blocked: already loading.");
          return;
      }
      isLoading = true;
      $('#loading-spinner').show();

      // 1. Генерируем карту виджетов в соответствии с вашим ТЗ
      const widgets = {};
      if (columns === 0) {
        console.warn("Columns not calculated, defaulting to 1");
        columns = 1; // Устанавливаем 1, если расчет не удался
      }

      for (let r = 0; r < linesToFetch; r++) {
        const row_idx = startLine + r;
        for (let c = 0; c < columns; c++) {
          // Имя виджета: l[hex-колонка][hex-строка]
          const widgetName = `l${c.toString(16)}${row_idx.toString(16).padStart(2, '0')}`;
          // Запрашиваем 1 тизер на 1 слот
          widgets[widgetName] = 1;
        }
      }

      if (Object.keys(widgets).length === 0) {
          console.log("No widgets to fetch.");
          isLoading = false;
          $('#loading-spinner').hide();
          return;
      }

      console.log("Fetching widgets:", widgets);

      // 2. Собираем полный payload для API /etc
      const payload = {
        uid: "user-id-placeholder-12345", // TODO: Заменить на реальный UID
        ip: "127.0.0.1", // TODO: Это поле должен заполнять бэкенд
        ua: navigator.userAgent,
        url: window.location.href,
        loc: "ru",
        w: window.innerWidth,
        h: window.innerHeight,
        d: window.devicePixelRatio || 1,
        widgets: widgets
      };

      // 3. Отправляем AJAX-запрос
      $.ajax({
        type: 'POST',
        url: '/etc',
        data: JSON.stringify(payload),
        contentType: 'application/json',
        dataType: 'json',
        success: function(response) {
          console.log("Received response:", response);
          if (response.widgets) {
            renderTeasers(response.widgets);
          } else {
            console.log("Response contained no 'widgets' key.");
          }
        },
        error: function(xhr, status, error) {
          console.error("Failed to fetch teasers:", status, error);
          // Можно показать сообщение об ошибке
        },
        complete: function() {
          isLoading = false;
          $('#loading-spinner').hide();
        }
      });
    }

    /**
     * Рендерит тизеры, полученные от API.
     * @param {Object} widgets - Объект {widgetName: [teaserArray]}
     */
    function renderTeasers(widgets) {
      const $feed = $('#teaser-feed');

      // Сортируем ключи, чтобы рендерить в правильном порядке
      // (l000, l100, l200, l001, l101, l201...)
      // Сортируем по строке (yy), затем по колонке (x)
      const sortedKeys = Object.keys(widgets).sort((a, b) => {
          // Извлекаем 'l', 'x', 'yy'
          const rowA = a.substring(2); // '00', '01'
          const colA = a.substring(1, 2); // '0', '1'
          const rowB = b.substring(2);
          const colB = b.substring(1, 2);

          if (rowA !== rowB) return parseInt(rowA, 16) - parseInt(rowB, 16);
          return parseInt(colA, 16) - parseInt(colB, 16);
      });

      console.log("Rendering widgets in order:", sortedKeys);

      let renderedCount = 0;
      for (const widgetName of sortedKeys) {
        const teasers = widgets[widgetName];
        if (teasers && teasers.length > 0) {
          // Мы просили 1 тизер (quantity=1), поэтому берем первый [0]
          const teaser = teasers[0];

          // Создаем HTML-разметку (убедитесь, что бэкенд отдает image и url)
          const imageUrl = teaser.image || 'https://placehold.co/400x200/eee/ccc?text=No+Image';
          // ИСПОЛЬЗУЕМ teaser.url (из ArticlePreviewSchema)
          const teaserUrl = teaser.url || '#';

          const teaserHtml = `
            <div class="teaser-widget" data-widget-id="${widgetName}">
              <a href="${teaserUrl}">
                <img src="${imageUrl}" alt="${teaser.title || ''}" class="teaser-image"
                     onerror="this.src='https://placehold.co/400x200/eee/ccc?text=Error';">
                <div class="teaser-content">
                  <h3 class="teaser-title">${teaser.title || 'Заголовок отсутствует'}</h3>
                  <p class="teaser-text">${teaser.text || 'Описание отсутствует'}</p>
                </div>
              </a>
            </div>
          `;
          $feed.append(teaserHtml);
          renderedCount++;
        }
      }
      console.log(`Rendered ${renderedCount} teasers.`);
    }

    /**
     * Сбрасывает ленту (очищает HTML и счетчики).
     */
    function resetFeed() {
      console.log("Resetting feed...");
      $('#teaser-feed').empty();
      currentLine = 0;
      isLoading = false;
      // Прерываем любые текущие AJAX-запросы, если это необходимо
      // (хотя `isLoading` флаг должен помочь)
    }

    /**
     * Загружает начальные 2 линии.
     */
    function loadInitialTeasers() {
      console.log("Loading initial teasers...");
      currentLine = 0;
      fetchTeasers(2, 0); // Загружаем первые 2 линии
    }

    /**
     * Загружает следующие 2 линии (для бесконечной прокрутки).
     */
    function loadMoreTeasers() {
      console.log("Loading more teasers...");
      // Увеличиваем счетчик линий ПОСЛЕ запроса, чтобы знать, с какой линии начать
      const lineToStart = currentLine + 2;
      fetchTeasers(2, lineToStart); // Загружаем 2 следующие линии
      currentLine = lineToStart; // Обновляем счетчик
    }

    /**
     * Обработчик "бесконечной" прокрутки.
     */
    function handleScroll() {
      // Не загружать, если уже идет загрузка
      if (isLoading) return;

      // Загружаем за 500px до конца страницы
      if ($(window).scrollTop() + $(window).height() > $(document).height() - 500) {
        loadMoreTeasers();
      }
    }

    /**
     * Обработчик изменения размера окна.
     */
    function handleResize() {
      console.log("Resize event detected");
      if (checkLayoutChange()) {
        // Если количество колонок изменилось,
        // перезагружаем всю ленту с нуля.
        resetFeed();
        loadInitialTeasers();
      }
    }

    // --- Инициализация ---
    // Ожидаем, пока CSS Grid отрисуется,
    // затем запускаем логику.
    setTimeout(() => {
        console.log("DOM ready, initializing...");
        if (checkLayoutChange()) { // Первоначальный расчет колонок
            loadInitialTeasers(); // Загрузка первого контента
        } else {
            // Если checkLayoutChange() вернул false (напр., 0 колонок)
            // пробуем еще раз
            setTimeout(() => {
                 console.log("Retrying layout check...");
                 if(checkLayoutChange()) {
                    loadInitialTeasers();
                 } else {
                     console.error("Could not determine grid columns. Defaulting to 1.");
                     columns = 1;
                     loadInitialTeasers();
                 }
            }, 100); // Даем еще 100ms на рендер
        }

        // Навешиваем обработчики
        $(window).on('scroll', debounce(handleScroll, 100)); // debounce для скролла
        $(window).on('resize', debounce(handleResize, 250));
    }, 10); // Небольшая задержка, чтобы grid успел отрисоваться

  });
</script>
{% endblock %}